vim9script noclear
set encoding=utf-8
scriptencoding utf-8

# ------------------------------------------------------
# åŸºæœ¬è¨­å®š {{{
set fileencodings=ucs-bom,utf-8,iso-2022-jp,cp932,euc-jp
set noexpandtab
set tabstop=3 # æ„å¤–ã¨ã‚ã‚Šãªæ°—ãŒã—ã¦ããŸâ€¦
set shiftwidth=0
set softtabstop=0
set autoindent
set smartindent
set breakindent
set backspace=indent,start,eol
set nf=alpha,hex
set virtualedit=block
set list
set listchars=tab:\|\ ,trail:-,extends:>,precedes:<,nbsp:%
set fillchars=
set cmdheight=1
set noshowcmd
set noshowmode
set display=lastline
set ambiwidth=double
set belloff=all
set ttimeoutlen=50
set wildmenu
set wildcharm=<Tab>
set autochdir
set backupskip=/var/tmp/*
set undodir=~/.vim/undo
set undofile
set updatetime=2000
set incsearch
set hlsearch

augroup vimrc
	# æ–°ã—ã„è‡ªç”±
	au!
augroup End
#}}} -------------------------------------------------------

# ------------------------------------------------------
# ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ {{{

# ã“ã‚“ãªæ„Ÿã˜
#   Each nmap,xmap j gj
#   â†’ nmap j gj | xmap j gj
# å…ˆé ­ä»¥å¤–ã«å·®ã—è¾¼ã‚“ã ã‚Šãƒã‚¹ãƒˆã—ãŸã„å ´åˆã¯ã“ã†
#   Each j,k Each nmap,xmap {1} {0} g{0}
#   â†’ nmap j gj | xmap j gj | nmap k gk | xmap k gk
# â€»ã“ã‚Œä½¿ã†ã‚ˆã‚Šã¹ãŸã§æ›¸ã„ãŸã»ã†ãŒèµ·å‹•ã¯é€Ÿã„
g:util_each_nest = 0
def! g:UtilEach(qargs: string)
	const [items, args] = qargs->split('^\S*\zs')
	g:util_each_nest += 1
	for i in items->split(',')
		var a = args->substitute('{0\?}', i, 'g')
		if a ==# args
			a = $'{i} {a}'
		endif
		execute a->substitute($"\{{g:util_each_nest}\}", '{}', 'g')
	endfor
	g:util_each_nest -= 1
enddef
command! -keepscript -nargs=* Each g:UtilEach(<q-args>)

# ãã®ä»–
command! -nargs=1 -complete=var Enable  <args> = 1
command! -nargs=1 -complete=var Disable <args> = 0

def BufIsSmth(): bool
	return &modified || ! empty(bufname())
enddef

def g:IndentStr(expr: any): string
	return matchstr(getline(expr), '^\s*')
enddef

def StayCurPos(expr: string)
	const len = getline('.')->len()
	var cur = getcurpos()
	execute expr
	cur[2] += getline('.')->len() - len
	setpos('.', cur)
enddef

# <Cmd>ã§defã‚’å®Ÿè¡Œã—ãŸã¨ãã®ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ«ãƒ¢ãƒ¼ãƒ‰ã®ç¯„å›²(è¡Œ)
def! g:VFirstLast(): list<number>
	return [line('.'), line('v')]->sort('n')
enddef

def! g:VRange(): list<number>
	const a = g:VFirstLast()
	return range(a[0], a[1])
enddef
#}}} -------------------------------------------------------

# ------------------------------------------------------
# ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ {{{

# è‡ªä½œãƒãƒãƒ¼ã‚¸ãƒ£ {{{
g:ezpack_home = expand($'{&pp->split(',')[0]}/pack/ezpack')
if !isdirectory(g:ezpack_home)
	system($'git clone https://github.com/utubo/vim-ezpack.git {g:ezpack_home}/opt/vim-ezpack')
	vimrc#ezpack#Install()
endif
command! EzpackInstall vimrc#ezpack#Install()
command! EzpackCleanUp vimrc#ezpack#CleanUp()
# }}}

# zenmode {{{
g:zenmode = {}
au vimrc User Vim9skkModeChanged zenmode#Invalidate()
#}}}

# vim9skk {{{
g:vim9skk = {
	keymap: {
		toggle: ['<C-j>', ';j'],
		midasi: [':', 'Q'],
	}
}
g:vim9skk_mode = '' # statuslineã§ã‚¨ãƒ©ãƒ¼ã«ãªã‚‰ãªã„ã‚ˆã†ã«å¿µã®ç‚ºè¨­å®šã—ã¦ãŠã
nnoremap ;j i<Plug>(vim9skk-enable)
# è¦‹å‡ºã—ãƒ¢ãƒ¼ãƒ‰ã§ã‚¹ã‚¿ãƒ¼ãƒˆã™ã‚‹
au vimrc User Vim9skkEnter feedkeys('Q')
# AZIKãƒ©ã‚¤ã‚¯ãªè¨­å®šã¨ã‹
au vimrc User Vim9skkInitPre vimrc#vim9skk#ApplySettings()
#}}}

# textobj-user {{{
Each onoremap,xnoremap ab <Plug>(textobj-multiblock-a)
Each onoremap,xnoremap ib <Plug>(textobj-multiblock-i)
g:textobj_multiblock_blocks = [
	[ "(", ")" ],
	[ "[", "]" ],
	[ "{", "}" ],
	[ '<', '>' ],
	[ '"', '"', 1 ],
	[ "'", "'", 1 ],
	[ ">", "<", 1 ],
	[ "ã€Œ", "ã€", 1 ],
]
call textobj#user#plugin('nonwhitespace', {
	'-': { 'pattern': '\S\+', 'select': ['a<Space>', 'i<Space>'], }
})
#}}}

filetype plugin indent on
#}}} -------------------------------------------------------

# ------------------------------------------------------
# ã‚¿ãƒ–å¹…ã‚„ã‚¿ãƒ–å±•é–‹ã‚’è‡ªå‹•è¨­å®š {{{
def SetupTabstop()
	const limit = 100
	const org = getpos('.')
	cursor(1, 1)
	if !!search('^\t', 'nc', limit)
		setlocal noexpandtab
		setlocal tabstop=3 # æ„å¤–ã¨ã‚ã‚Šãªæ°—ãŒã—ã¦ããŸâ€¦
	elseif !!search('^  \S', 'nc', limit)
		setlocal expandtab
		setlocal tabstop=2
	elseif !!search('^    \S', 'nc', limit)
		setlocal expandtab
		setlocal tabstop=4
	endif
	&shiftwidth = &tabstop
	&softtabstop = &tabstop
	setpos('.', org)
enddef
au vimrc BufReadPost * SetupTabstop()
#}}} -------------------------------------------------------

# ------------------------------------------------------
# æŠ˜ã‚Šç•³ã¿ {{{
# ã“ã‚“ãªã‹ã‚“ã˜ã§ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆã«åˆã‚ã›ã¦è¡¨ç¤ºğŸ“ {{{
def! g:MyFoldText(): string
	const src = getline(v:foldstart)
	const indent = repeat(' ', indent(v:foldstart))
	if &foldmethod ==# 'indent'
		return $'{indent}ğŸ“ {v:foldend - v:foldstart + 1}lines'
	else
		const text = src->substitute(matchstr(&foldmarker, '^[^,]*'), '', '')->trim()
		return $'{indent}{text} ğŸ“'
	endif
enddef
set foldtext=g:MyFoldText()
set fillchars+=fold:\ # æŠ˜ã‚Šç•³ã¿æ™‚ã®ã€Œ-ã€ã¯åŠè§’ç©ºç™½
au vimrc ColorScheme * {
	hi! link Folded Delimiter
	hi! link ALEVirtualTextWarning ALEWarningSign
	hi! link ALEVirtualTextError ALEErrorSign
}
#}}}
# ãã®ä»–æŠ˜ã‚ŠãŸãŸã¿é–¢ä¿‚ {{{
set foldmethod=marker
au vimrc FileType markdown,yaml setlocal foldlevelstart=99 foldmethod=indent
au vimrc BufReadPost * :silent! normal! zO
nnoremap <expr> h (col('.') ==# 1 && 0 < foldlevel('.') ? 'zc' : 'h')
nnoremap Z<Tab> <Cmd>set foldmethod=indent<CR>
nnoremap Z{ <Cmd>set foldmethod=marker<CR>
nnoremap Zy <Cmd>set foldmethod=syntax<CR>
xnoremap zf <ScriptCmd>vimrc#myutil#Zf()<CR>
nnoremap zd <ScriptCmd>vimrc#myutil#Zd()<CR>
nnoremap <silent> g; g;zO
#}}}
#}}} -------------------------------------------------------

# ------------------------------------------------------
# ãƒãƒƒãƒ•ã‚¡ã®æƒ…å ±ã‚’è‰²ä»˜ãã§è¡¨ç¤º {{{
def ShowBufInfo(event: string = '')
	if &ft ==# 'qf'
		return
	endif

	var isReadPost = event ==# 'BufReadPost'
	if isReadPost && !filereadable(expand('%'))
		# ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã¨ã‹ãŒä¸€æ™‚çš„ãªbufnameã‚’ä»˜ä¸ã—ã¦é–‹ã„ãŸå ´åˆã¯ç„¡è¦–ã™ã‚‹
		return
	endif

	const ruler = $' {line(".")}:{col(".")}'

	var msg = []
	add(msg, ['Title', $'"{bufname()}"'])
	add(msg, ['Normal', ' '])
	if &modified
		add(msg, ['Delimiter', '[+]'])
		add(msg, ['Normal', ' '])
	endif
	if !isReadPost && !filereadable(expand('%'))
		add(msg, ['Tag', '[New]'])
		add(msg, ['Normal', ' '])
	endif
	if &readonly
		add(msg, ['WarningMsg', '[RO]'])
		add(msg, ['Normal', ' '])
	endif
	const w = wordcount()
	if isReadPost || w.bytes !=# 0
		add(msg, ['Constant', printf('%dL, %dB', w.bytes ==# 0 ? 0 : line('$'), w.bytes)])
		add(msg, ['Normal', ' '])
	endif
	add(msg, ['MoreMsg', &ff])
	add(msg, ['Normal', ' '])
	const enc = empty(&fenc) ? &encoding : &fenc
	add(msg, [enc ==# 'utf-8' ? 'MoreMsg' : 'WarningMsg', enc])
	add(msg, ['Normal', ' '])
	add(msg, ['MoreMsg', &ft])
	var msglen = 0
	const maxlen = &columns - len(ruler) - 2
	for i in reverse(range(0, len(msg) - 1))
		var s = msg[i][1]
		var d = strdisplaywidth(s)
		msglen += d
		if maxlen < msglen
			const l = maxlen - msglen + d
			while !empty(s) && l < strdisplaywidth(s)
				s = s[1 :]
			endwhile
			msg[i][1] = s
			msg = msg[i : ]
			insert(msg, ['SpecialKey', '<'], 0)
			break
		endif
	endfor
	add(msg, ['Normal', repeat(' ', maxlen - msglen) .. ruler])
	redraw
	echo ''
	for m in msg
		execute 'echohl' m[0]
		echon m[1]
	endfor
	echohl Normal
enddef

nnoremap <script> <C-g> <ScriptCmd>ShowBufInfo()<CR>
au vimrc BufNewFile,BufReadPost,BufWritePost * ShowBufInfo('BufNewFile')
#}}} -------------------------------------------------------

# ------------------------------------------------------
# è‰² {{{
nnoremap <expr> ZB $"<Cmd>set background={&background ==# 'dark' ? 'light' : 'dark'}<CR>"
au vimrc ColorSchemePre * {
	g:rcsv_colorpairs = [
		['105', '#9999ee'], ['117', '#99ccee'], ['120', '#99ee99'],
		['228', '#eeee99'], ['212', '#ee99cc'], ['177', '#cc99ee']
	]
}

def GetAttr(id: number, name: string): string
	const v = synIDattr(id, name)->matchstr(has('gui') ? '.*[^0-9].*' : '^[0-9]\+$')
	return !v ? 'NONE' : v
enddef

def GetHl(name: string): any
	const id = hlID(name)->synIDtrans()
	return { fg: GetAttr(id, 'fg'), bg: GetAttr(id, 'bg') }
enddef

def MyHighlight()
	hi! link CmdHeight0Horiz MoreMsg
	const x = has('gui') ? 'gui' : 'cterm'
	const signBg = GetHl('LineNr').bg
	execute $'hi LspDiagSignErrorText   {x}bg={signBg} {x}fg={GetHl("ErrorMsg").fg}'
	execute $'hi LspDiagSignHintText    {x}bg={signBg} {x}fg={GetHl("Question").fg}'
	execute $'hi LspDiagSignInfoText    {x}bg={signBg} {x}fg={GetHl("Pmenu").fg}'
	execute $'hi LspDiagSignWarningText {x}bg={signBg} {x}fg={GetHl("WarningMsg").fg}'
enddef

au vimrc VimEnter,ColorScheme * MyHighlight()

# å¥½ã¿ã§ãƒã‚¤ãƒ©ã‚¤ãƒˆ
# vimrcå†èª­ã¿è¾¼ã¿ã§ã‚¯ãƒªã‚¢&å†è¨­å®šã•ã‚Œãªã„ã‘ã©é¢å€’ã ã‹ã‚‰ãƒ¨ã‚·
def MyMatches()
	if exists('w:my_matches') && !empty(getmatches())
		return
	endif
	w:my_matches = 1
	matchadd('String', 'ã€Œ[^ã€]*ã€')
	matchadd('Label', '^\s*â– .*$')
	matchadd('Delimiter', 'WARN\|æ³¨æ„\|æ³¨:\|[â˜…â€»][^\s()ï¼ˆï¼‰]*')
	matchadd('Todo', 'TODO')
	matchadd('Error', 'ERROR')
	matchadd('Delimiter', '- \[ \]')
	matchadd('SpellRare', '[ï½-ï½šï¼¡-ï¼ºï¼-ï¼™ï¼ˆï¼‰ï½›ï½]')
	# å…¨è§’ç©ºç™½ã¨åŠè§’å¹…ã®å††è¨˜å·
	matchadd('SpellBad', '[ã€€Â¥]')
	# ç¨€ã«ã‚ˆãtypoã™ã‚‹å˜èª(æ°—ã¥ã„ãŸã‚‰è¿½åŠ ã™ã‚‹)
	matchadd('SpellBad', 'stlye')
enddef
au vimrc VimEnter,WinEnter * MyMatches()

# æ–‡æœ«ç©ºç™½(&listãŒæœ‰åŠ¹ã®ã¨ãã ã‘SpellBadã§ç›®ç«‹ãŸã›ã‚‹)
def HiTail()
	if &list && !exists('w:hi_tail')
		w:hi_tail = matchadd('SpellBad', '\s\+$')
	elseif !&list && exists('w:hi_tail')
		# calendar.vimç­‰ã§è¦‹ã¥ã‚‰ããªã‚‹ã®ã§ãã®å¯¾å¿œ
		matchdelete(w:hi_tail)
		unlet w:hi_tail
	endif
enddef
au vimrc OptionSet list silent! HiTail()
# matchaddã¯ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦å˜ä½ã ãŒã€`setlocal list`ã‚’è€ƒæ…®ã—ã¦Buf...ã‚¤ãƒ™ãƒ³ãƒˆã§å®Ÿè¡Œã™ã‚‹
au vimrc BufNew,BufReadPost * silent! HiTail()

silent! syntax enable
set t_Co=256
set background=light
silent! colorscheme girly
#}}} -------------------------------------------------------

# ------------------------------------------------------
# çµ‚ã‚ã‚Šã« {{{
if '~/.vimrc_local'->expand()->filereadable()
	source ~/.vimrc_local
endif

def OpenLastfile()
	var lastfile = get(v:oldfiles, 0, '')->expand()
	if lastfile->filereadable()
		execute 'edit' lastfile
	endif
enddef
au vimrc VimEnter * ++nested if !BufIsSmth() | OpenLastfile() | endif
au vimrc SafeStateAgain * ++once vimrc#lazyload#LazyLoad()
#}}}

# ------------------------------------------------------
# ãƒ¡ãƒ¢ {{{
# <F1> fern <S-F1>ã§ãƒ•ã‚©ãƒ«ãƒ€ã‚’é–‹ã(win32)
# <F2> MRU
# <F3>
# <F4>
# <F5> æ—¥ä»˜é–¢ä¿‚
# <F6>
# <F7>
# <F8>
# <F9> ã“ã“ã¾ã§ã‚ˆã‚“ã 
# <F10> ãƒ˜ãƒƒãƒ€è¡Œã‚’è¡¨ç¤º(ã‚ã‚“ã¾ã‚Šä½¿ã‚ãªã„)
# <F11> è¡Œç•ªå·è¡¨ç¤ºåˆ‡æ›¿
# <F12> æŠ˜ã‚Šè¿”ã—è¡¨ç¤ºåˆ‡æ›¿
#}}} -------------------------------------------------------

